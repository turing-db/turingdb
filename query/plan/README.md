
ScanNodes
ScanOutEdges

Example: a->n->b, n->x

First branch:
ScanNodes-->a-->GetOutEdges--target-->n-->GetOutEdges--target-->b
                  ind1                     ind2

Second branch:
n-->GetOutEdges--target-->x
        ind3

In the normal sequential branch TransformStep would do:
a--> (ind1, n) --> (ind2, b)

In the second branch we have:
n--> (ind3, x)

It is a kind of cross product of one by the other

Expected result:
a n b x
0 1 2 2
0 1 2 3
0 1 2 4
0 1 3 2
0 1 3 3
0 1 3 4
...

So it is (Branch 1) x (Branch 2)
Maybe we can do the cross product symbolically using indices

Is it necessarily a cross product? What if we have constraints on the second branch which in fact constrains the choice of n?

a-->n-->b, n-->x{x.mass > 42}

First branch:
ScanNodes-->a-->GetOutEdges--target-->n-->GetOutEdges--target-->b
                   ind1                     ind2

Second branch:
n-->GetOutEdges--target-->Filter{mass > 42}-->x
       ind3                   ind4

a, (ind1, n), (ind2, b)
n, (ind3, t1), (ind4, x)

A join without any condition degenerates into a simple cross product.
The cross product is just the most general case of a join.

--> We can join or keep the indices that are both in ind2 and ind3

Or is it in fact a join of the TABLE generated by the first branch
with the TABLE generated by the second branch on the variable n?

Like:
a| n| b|  join on n |n| x|
 |  |  |            | | x|
 |  |  |            | | x|

Let's meditate a bit on the difference between fully materializing the results
of each branch and join the tables / vs. / use indices and perform an intersection of indices on n

What happens if we define indInter = ind2 INTER ind3
a, (ind1, n), (indInter, b)
n, FUCK!!! it's not ind2 INTER ind3 !!!!!  it's ind2 INTER (ind4 applied onto ind3) !!!

Ok so moral of the story: We may need to do the job of TransformStep to perform the application of indices anyway!!

So does it mean that there is no other choice than doing join after materialization of the branches??

It's maybe even more true if we have a chain of filters on each branch separately. 
There is still the traversal of the indices chains to be done.

So the branches seem to be:
1. Compute each branch
2. Materialize the block of each branch using TransformStep
3. Compute the join of the blocks using the pivot variable
























       


